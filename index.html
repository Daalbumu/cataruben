<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Visor Torre 156</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #c{width:100%;height:100%;display:block}
  #tooltip{
    position:fixed;pointer-events:none;padding:.4rem .6rem;background:rgba(0,0,0,.75);
    border:1px solid rgba(255,255,255,.2);border-radius:6px;transform:translate(12px,12px);
    display:none;font-size:14px;white-space:nowrap
  }
  #hud{
    position:fixed;left:12px;top:12px;background:rgba(0,0,0,.55);padding:.6rem .8rem;border-radius:8px;
    border:1px solid rgba(255,255,255,.2);max-width:52ch;font-size:14px;line-height:1.15;z-index:5
  }
  #hud h3{margin:.2rem 0 .4rem;font-size:15px} #hud code{font-size:13px}
  #loading{
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.6);
    padding:.8rem 1rem;border:1px solid rgba(255,255,255,.2);border-radius:8px;z-index:10
  }
  /* Panel de gráficas */
  #charts {
    position: fixed; right: 12px; top: 12px; width: 520px; max-height: calc(100% - 24px);
    background: rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.2); border-radius: 8px;
    padding: .6rem .8rem; overflow: auto; z-index: 6;
  }
  #charts h3 { margin:.2rem 0 .4rem; font-size:15px }
  #charts .row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  #charts label{font-size:12px;opacity:.85}
  #charts input, #charts select {
    background:#1b1b1b; color:#fff; border:1px solid rgba(255,255,255,.2);
    padding:.25rem .4rem; border-radius:6px; font-size:12px;
  }
  #charts button {
    cursor:pointer; background:#2a2a2a; color:#fff; border:1px solid rgba(255,255,255,.2);
    padding:.35rem .6rem; border-radius:6px; font-size:12px;
  }
  #charts .grid { display:grid; grid-template-columns: 1fr; gap: 10px; margin-top:.5rem }
  #charts canvas { background: rgba(255,255,255,.04); border-radius: 6px; }
</style>

<!-- three.js import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<!-- Chart.js para las gráficas -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
</head>
<body>
<canvas id="c"></canvas>
<div id="tooltip"></div>

<div id="hud">
  <h3>Datos (último valor por variable)</h3>
  <div id="station">Torre 156: <code>—</code></div>
  <div style="margin-top:.35rem;opacity:.7;">Se actualiza cada ~10 min</div>
</div>

<!-- Panel de gráficas con rango -->
<div id="charts">
  <div class="row" style="margin-bottom:.4rem;">
    <h3 style="flex:1">Gráficas — Torre 156</h3>
  </div>
  <div class="row">
    <label>Desde:&nbsp;<input type="datetime-local" id="dtFrom"></label>
    <label>Hasta:&nbsp;<input type="datetime-local" id="dtTo"></label>
    <button id="btnApply">Aplicar rango</button>
    <span style="flex:1"></span>
    <label>Últimos&nbsp;
      <select id="selDays">
        <option value="3">3d</option>
        <option value="7">7d</option>
        <option value="10" selected>10d</option>
        <option value="14">14d</option>
        <option value="30">30d</option>
      </select>
    </label>
    <button id="btnLast">Usar últimos N días</button>
  </div>

  <div class="grid">
    <canvas id="chart_H"   height="160"></canvas>
    <canvas id="chart_LE"  height="160"></canvas>
    <canvas id="chart_Rn"  height="160"></canvas>
    <canvas id="chart_CH4" height="160"></canvas>
    <canvas id="chart_CO2" height="160"></canvas>
  </div>
</div>

<div id="loading">Cargando modelo…</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls }  from "three/addons/controls/OrbitControls.js";
import { GLTFLoader }     from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader }    from "three/addons/loaders/DRACOLoader.js";

/* ======== CONFIG ======== */
const PROXY_URL  = "https://flux-proxy.daalbumu.workers.dev/series"; // tu Worker
const GLB_URL    = "./cateruben2.glb";                                // tu modelo
const STATION_ID = 156;                                              // estación solicitada
const VARIABLES  = ["H","LE","Rn_1_1_1","ch4_flux","co2_flux"];

/* --- Canvas + HUD --- */
const canvas  = document.getElementById('c');
const tooltip = document.getElementById('tooltip');
const loading = document.getElementById('loading');
const hudWrap = document.getElementById('station');
const hud     = hudWrap.querySelector('code');

/* --- (opcional) etiquetas por nombre si no vienen en userData.label --- */
const LABELS = {
  "Mesh_0.011": "Machín petrolero",
  "Mesh_0.002": "1 Cámaras automatizadas LI-COR 8200",
  "Mesh_0.003": "2 Cámaras automatizadas LI-COR 8200",
  "Mesh_0.004": "3 Cámaras automatizadas LI-COR 8200",
  "Mesh_0.005": "4 Cámaras automatizadas LI-COR 8200",
  "Mesh_0.018": "1 PALAS",
  "Mesh_0.059": "2 PALAS",
  "Mesh_0.001": "torre eddy covarience sur",
  "Mesh_0.008": "torre eddy covarience norte",
  "Mesh_0.034": "Llanito 114"
};
const canon = s => String(s||"").toLowerCase().replace(/[^\w]/g,"");
const CANON_LABELS = Object.fromEntries(Object.entries(LABELS).map(([k,v])=>[canon(k),v]));

/* --- Three.js base --- */
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(50, 2, 0.1, 50000);
camera.position.set(8, 8, 12);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.HemisphereLight(0xffffff, 0x303030, 0.9));
const dlight = new THREE.DirectionalLight(0xffffff, 1.2); dlight.position.set(20,30,20); scene.add(dlight);

/* --- Centrado --- */
function frameObject(object, camera, controls, padding = 1.2) {
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxSize = Math.max(size.x, size.y, size.z);
  const fitH = maxSize / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)));
  const fitW = fitH / camera.aspect;
  const distance = padding * Math.max(fitH, fitW);
  const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize().multiplyScalar(distance);
  controls.target.copy(center);
  camera.position.copy(center).add(dir);
  camera.near = distance / 100; camera.far = distance * 100;
  camera.updateProjectionMatrix(); controls.update();
}

/* --- GLB + Draco --- */
let mixers = [];
const draco = new DRACOLoader();
draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");
draco.preload();

const loader = new GLTFLoader();
loader.setDRACOLoader(draco);

loader.load(
  GLB_URL,
  (gltf)=>{
    loading.textContent = "Procesando escena…";
    scene.add(gltf.scene);
    if (gltf.animations?.length) {
      const mixer = new THREE.AnimationMixer(gltf.scene);
      gltf.animations.forEach(clip=>{ const a=mixer.clipAction(clip); a.loop=THREE.LoopRepeat; a.play(); });
      mixers.push(mixer);
    }
    frameObject(gltf.scene, camera, controls, 1.3);
    loading.style.display = "none";
  },
  (xhr)=>{
    const t = xhr.total||0;
    loading.textContent = t ? `Cargando modelo… ${Math.round((xhr.loaded/t)*100)}%` : "Cargando modelo…";
  },
  (err)=>{
    console.error("Error GLB:", err);
    loading.textContent = "Error cargando el modelo. Revisa la consola (F12).";
  }
);

/* --- Tooltips --- */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(-1,-1);
window.addEventListener('pointermove', e=>{
  const r = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - r.left) / r.width ) * 2 - 1;
  mouse.y = -((e.clientY - r.top ) / r.height) * 2 + 1;
  tooltip.style.left = `${e.clientX}px`; tooltip.style.top = `${e.clientY}px`;
});
function getLabelFrom(object){
  let o = object;
  while (o) { const ud = o.userData||{}; if (ud.label && String(ud.label).trim()!=="") return String(ud.label); o=o.parent; }
  const c = canon(object.name);
  return CANON_LABELS[c] || object.name;
}
function updateTooltip(){
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(scene.children, true);
  const hit = hits.find(h => h.object?.isMesh);
  tooltip.style.display = hit?.object ? 'block' : 'none';
  if (hit?.object) tooltip.textContent = getLabelFrom(hit.object);
}

/* --- Render loop --- */
function resize(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  if (canvas.width !== w || canvas.height !== h) {
    renderer.setSize(w, h, false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
}
let last = performance.now();
function animate(now){
  const dt = (now - last)/1000; last = now;
  resize(); controls.update();
  mixers.forEach(m=>m.update(dt));
  updateTooltip();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ===== Datos de FluxSuite (HUD + Gráficas) ===== */
const lastPoint = (list)=>{ if(!Array.isArray(list)) return null; for(let i=list.length-1;i>=0;i--){const [ts,v]=list[i]; if(v!=null) return {ts,v};} return null; };
const toEpochS = (dtLocal)=> Math.floor(new Date(dtLocal).getTime()/1000);
const fmtTs = (ms)=> new Date(ms).toLocaleString([], {hour12:false, month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'});

// --- HUD: últimos valores (cada 10 min)
async function fetchStationWindow(stationId, startS, endS){
  const qs = new URLSearchParams({
    stationId:String(stationId),
    field: VARIABLES.join(","),
    startTime:String(startS),
    endTime:String(endS),
    format:"highcharts"
  });
  const r = await fetch(`${PROXY_URL}?${qs}`, { cache:"no-store" });
  if(!r.ok) throw new Error("Proxy error "+r.status);
  return r.json();
}
async function refreshDataHUD(){
  try{
    const nowS = Math.floor(Date.now()/1000);
    const startS = nowS - 8*24*3600; // 8 días
    const d = await fetchStationWindow(STATION_ID, startS, nowS);
    const txt = VARIABLES.map(k=>{
      const serie = (d.series?.[k]?.[0]?.data) || [];
      const p = lastPoint(serie);
      return `${k}: ${p ? Number(p.v).toFixed(2) : 'N/A'}`;
    }).join(" · ");
    hudWrap.firstChild.textContent = `Torre ${STATION_ID}: `;
    hud.textContent = txt;
  }catch(e){ console.error(e); }
}
refreshDataHUD(); setInterval(refreshDataHUD, 600_000); // 10 min

/* --- CHARTS --- */
const CHART_FIELDS = ["H","LE","Rn_1_1_1","ch4_flux","co2_flux"];
const CHART_CANVAS = { H:"chart_H", LE:"chart_LE", Rn_1_1_1:"chart_Rn", ch4_flux:"chart_CH4", co2_flux:"chart_CO2" };
const charts = {};
function upsertChart(canvasId, label, labels, values){
  const ctx = document.getElementById(canvasId); if(!ctx) return;
  const existing = charts[canvasId];
  if(existing){
    existing.data.labels = labels; existing.data.datasets[0].data = values; existing.update(); return;
  }
  charts[canvasId] = new Chart(ctx, {
    type:'line',
    data:{ labels, datasets:[{ label, data:values, fill:false, tension:0.2, pointRadius:0, borderWidth:2 }] },
    options:{
      animation:false, responsive:true,
      plugins:{ legend:{display:false}, tooltip:{mode:'index', intersect:false} },
      scales:{
        x:{ ticks:{ color:'#ddd', maxTicksLimit:6 }, grid:{ color:'rgba(255,255,255,.08)' } },
        y:{ ticks:{ color:'#ddd' }, grid:{ color:'rgba(255,255,255,.08)' } }
      }
    }
  });
}
async function fetchSeriesForCharts(stationId, startS, endS){
  const qs = new URLSearchParams({
    stationId:String(stationId), field:CHART_FIELDS.join(","), startTime:String(startS), endTime:String(endS), format:"highcharts"
  });
  const r = await fetch(`${PROXY_URL}?${qs}`, { cache:"no-store" });
  if(!r.ok) throw new Error("Proxy error "+r.status);
  const data = await r.json();
  const out = {};
  for(const f of CHART_FIELDS){
    const serie = data?.series?.[f]?.[0]?.data || [];
    const labels = [], values = [];
    for(const [ts,v] of serie){ if(v==null) continue; labels.push(fmtTs(ts)); values.push(v); }
    out[f] = {labels, values};
  }
  return out;
}
async function drawChartsRange(startS, endS){
  try{
    const series = await fetchSeriesForCharts(STATION_ID, startS, endS);
    upsertChart(CHART_CANVAS.H, "H (W/m²)", series.H.labels, series.H.values);
    upsertChart(CHART_CANVAS.LE, "LE (W/m²)", series.LE.labels, series.LE.values);
    upsertChart(CHART_CANVAS["Rn_1_1_1"], "Rn_1_1_1 (W/m²)", series["Rn_1_1_1"].labels, series["Rn_1_1_1"].values);
    upsertChart(CHART_CANVAS.ch4_flux, "ch4_flux (µmol/m²s)", series.ch4_flux.labels, series.ch4_flux.values);
    upsertChart(CHART_CANVAS.co2_flux, "co2_flux (µmol/m²s)", series.co2_flux.labels, series.co2_flux.values);
  }catch(e){ console.error("Charts error:", e); }
}

/* --- UI rango de fechas --- */
const dtFrom = document.getElementById('dtFrom');
const dtTo   = document.getElementById('dtTo');
const btnApply = document.getElementById('btnApply');
const btnLast  = document.getElementById('btnLast');
const selDays  = document.getElementById('selDays');

// set defaults: últimos 10 días
(function setDefaults(){
  const now = new Date();
  const from = new Date(now.getTime() - 10*24*3600*1000);
  const toLocal = (d)=> {
    const pad = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };
  dtFrom.value = toLocal(from);
  dtTo.value   = toLocal(now);
})();

// aplicar rango exacto
btnApply.addEventListener('click', ()=>{
  if(!dtFrom.value || !dtTo.value) return;
  const startS = toEpochS(dtFrom.value), endS = toEpochS(dtTo.value);
  drawChartsRange(startS, endS);
});

// usar últimos N días
btnLast.addEventListener('click', ()=>{
  const days = Number(selDays.value||10);
  const endS = Math.floor(Date.now()/1000);
  const startS = endS - days*24*3600;
  drawChartsRange(startS, endS);
});

// dibuja al inicio con últimos 10 días
(function initialCharts(){
  const endS = Math.floor(Date.now()/1000);
  const startS = endS - 10*24*3600;
  drawChartsRange(startS, endS);
})();
</script>
</body>
</html>
